<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebGL Plasma with Custom Palette</title>
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
        height: 100%;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
      #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 10px;
        font-family: sans-serif;
        border-radius: 8px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>
    <div id="ui">
      <label
        >Speed:
        <input
          type="range"
          id="speed"
          min="0.1"
          max="3"
          step="0.1"
          value="1" /> </label
      ><br />
      <label
        >Palette:
        <select id="palette">
          <option value="fire">Fire</option>
          <option value="ocean">Ocean</option>
          <option value="sunset">Sunset</option>
        </select>
      </label>
    </div>
    <script>
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl');

      // Resize canvas to full screen
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
      }
      resizeCanvas();

      // === Shader Sources ===
      const PALETTE_SIZE = 4;

      const vertexShaderSrc = `
  attribute vec2 a_position;
  varying vec2 v_uv;
  void main() {
    v_uv = a_position * 0.5 + 0.5;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`;

      const plasmaFrag = `
  precision mediump float;
  uniform float u_time;
  uniform float u_speed;
  varying vec2 v_uv;

  float plasma(vec2 p, float t) {
    float v = 0.0;
    v += sin(p.x * 3.0 + t);
    v += sin(p.y * 4.0 + t * 1.3);
    v += sin((p.x + p.y) * 2.0 + t * 0.7);
    v += sin(length(p) * 4.0 - t * 1.5);
    v += sin(dot(p, vec2(sin(t), cos(t))) * 5.0);
    return v / 5.0;
  }

  void main() {
    vec2 uv = v_uv * 2.0 - 1.0;
    uv *= 3.0;
    float t = u_time * u_speed;
    float v = plasma(uv, t);
    v = 0.5 + 0.5 * sin(v * 3.0 + t);
    gl_FragColor = vec4(vec3(v), 1.0);
  }
`;

      const paletteFrag = `
  precision mediump float;
  #define PALETTE_SIZE ${PALETTE_SIZE}
  varying vec2 v_uv;
  uniform sampler2D u_texture;
  uniform vec3 u_palette[PALETTE_SIZE];

  void main() {
    float t = texture2D(u_texture, v_uv).r;
    float scaled = t * float(PALETTE_SIZE - 1);
    int idx = int(floor(scaled));
    float f = fract(scaled);
    vec3 col = mix(
      u_palette[idx],
      u_palette[min(idx + 1, PALETTE_SIZE - 1)],
      f
    );
    gl_FragColor = vec4(col, 1.0);
  }
`;

      // === Shader Setup ===
      function compileShader(type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          throw new Error(gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      function createProgram(vsSrc, fsSrc) {
        const program = gl.createProgram();
        const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
        const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw new Error(gl.getProgramInfoLog(program));
        }
        return program;
      }

      // === Programs & Buffers ===
      const plasmaProgram = createProgram(vertexShaderSrc, plasmaFrag);
      const paletteProgram = createProgram(vertexShaderSrc, paletteFrag);

      const posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
        gl.STATIC_DRAW
      );

      function createRenderTarget(w, h) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          w,
          h,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          null
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          tex,
          0
        );

        return { framebuffer: fb, texture: tex };
      }

      const rtt = createRenderTarget(canvas.width, canvas.height);

      // === Uniforms ===
      const plasmaLocs = {
        a_position: gl.getAttribLocation(plasmaProgram, 'a_position'),
        u_time: gl.getUniformLocation(plasmaProgram, 'u_time'),
        u_speed: gl.getUniformLocation(plasmaProgram, 'u_speed')
      };

      const paletteLocs = {
        a_position: gl.getAttribLocation(paletteProgram, 'a_position'),
        u_texture: gl.getUniformLocation(paletteProgram, 'u_texture')
      };

      // === Palettes ===
      const palettes = {
        fire: [
          [0.1, 0.0, 0.0],
          [0.9, 0.2, 0.0],
          [1.0, 0.6, 0.0],
          [1.0, 1.0, 0.8]
        ],
        ocean: [
          [0.0, 0.1, 0.3],
          [0.0, 0.4, 0.6],
          [0.0, 0.7, 0.9],
          [0.8, 1.0, 1.0]
        ],
        sunset: [
          [0.2, 0.0, 0.3],
          [0.8, 0.2, 0.5],
          [1.0, 0.5, 0.2],
          [1.0, 0.9, 0.3]
        ]
      };

      let currentPaletteName = 'fire';

      // === UI Control ===
      document.getElementById('palette').addEventListener('change', (e) => {
        currentPaletteName = e.target.value;
      });

      function setPaletteUniforms(paletteName) {
        const colors = palettes[paletteName];
        for (let i = 0; i < colors.length; i++) {
          const loc = gl.getUniformLocation(paletteProgram, `u_palette[${i}]`);
          gl.uniform3fv(loc, new Float32Array(colors[i]));
        }
      }

      // === Render Loop ===
      function render(time) {
        time *= 0.001;
        resizeCanvas();
        gl.viewport(0, 0, canvas.width, canvas.height);

        const speed = parseFloat(document.getElementById('speed').value);

        // PASS 1: Plasma → texture
        gl.useProgram(plasmaProgram);
        gl.bindFramebuffer(gl.FRAMEBUFFER, rtt.framebuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.enableVertexAttribArray(plasmaLocs.a_position);
        gl.vertexAttribPointer(plasmaLocs.a_position, 2, gl.FLOAT, false, 0, 0);
        gl.uniform1f(plasmaLocs.u_time, time);
        gl.uniform1f(plasmaLocs.u_speed, speed);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // PASS 2: Texture → screen with palette
        gl.useProgram(paletteProgram);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.enableVertexAttribArray(paletteLocs.a_position);
        gl.vertexAttribPointer(
          paletteLocs.a_position,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, rtt.texture);
        gl.uniform1i(paletteLocs.u_texture, 0);
        setPaletteUniforms(currentPaletteName);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
