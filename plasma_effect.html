<body style="padding: 0; margin: 0">
  <canvas id="glcanvas" height="1000" width="1000"></canvas>
  <script type="text/javascript">
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');

    const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
          v_uv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

    const fragmentShaderSource = `
precision mediump float;

uniform vec3 u_paletteA;
uniform vec3 u_paletteB;
uniform vec3 u_paletteC;
uniform vec3 u_paletteD;

uniform float u_time;
varying vec2 v_uv;

// Inigo Quilez's palette function
vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
    return a + b * cos(6.28318 * (c * t + d));
}

// More chaotic plasma function
float plasma(vec2 p, float t) {
    float v = 0.0;
    v += sin(p.x * 3.0 + t * 1.0);
    v += sin(p.y * 4.0 + t * 1.3);
    v += sin((p.x + p.y) * 2.0 + t * 0.7);
    v += sin(length(p) * 4.0 - t * 1.5);
    v += sin(dot(p, vec2(sin(t), cos(t))) * 5.0);
    return v / 5.0;
}

void main() {
    vec2 uv = v_uv * 2.0 - 1.0;
    uv *= 1.0; // zoom in
    float t = u_time * 0.5; // control speed

    float v = plasma(uv, t);

    // Normalize v to 0..1
    float n = 0.5 + 0.5 * sin(v * 3.0 + t);

    // Use a palette: pastel plasma
    // vec3 color = palette(n,
    //    vec3(0.5, 0.5, 0.5),  // base
    //    vec3(0.5, 0.5, 0.5),  // contrast
    //    vec3(1.0, 1.0, 1.0),  // frequency
    //    vec3(0.0, 0.1, 0.2)   // phase
    // );

    vec3 color = palette(n, u_paletteA, u_paletteB, u_paletteC, u_paletteD);

    gl_FragColor = vec4(color, 1.0);
}`;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      return shader;
    }

    const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(
      gl.FRAGMENT_SHADER,
      fragmentShaderSource
    );

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
      gl.STATIC_DRAW
    );

    const palette = {
      mono: {
        a: [0.2, 0.2, 0.2],
        b: [0.3, 0.3, 0.3],
        c: [1.0, 1.0, 1.0],
        d: [0.0, 0.0, 0.0]
      }
    };

    const p = 'mono';

    const a_position = gl.getAttribLocation(program, 'a_position');
    const u_time = gl.getUniformLocation(program, 'u_time');

    gl.useProgram(program);

    gl.uniform3fv(gl.getUniformLocation(program, 'u_paletteA'), palette[p].a);
    gl.uniform3fv(gl.getUniformLocation(program, 'u_paletteB'), palette[p].b);
    gl.uniform3fv(gl.getUniformLocation(program, 'u_paletteC'), palette[p].c);
    gl.uniform3fv(gl.getUniformLocation(program, 'u_paletteD'), palette[p].d);

    function render(time) {
      time *= 0.001; // convert ms to seconds

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.enableVertexAttribArray(a_position);
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
      gl.uniform1f(u_time, time * 0.25);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
